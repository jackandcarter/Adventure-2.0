{\rtf1\ansi\ansicpg1252\cocoartf2865
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 # AdventureBot 2.0 \'96 Development Guide\
\
This is **Guide Page 1 of 10** for AdventureBot 2.0.\
\
All 10 guide pages together define:\
- The game vision and constraints.\
- Unity client architecture and UI rules (no runtime-generated UI layouts).\
- Server architecture, networking, and message patterns.\
- Database schema (MariaDB on Ubuntu VPS).\
- Core RPG systems (stats, abilities, elements, status effects, trance).\
- Dungeon generation, room templates, and editor tools.\
- Unity scene setup and prefabs.\
- A task blueprint for generating the initial codebase.\
\
When coding in this repo, **read all 10 guide pages fully before implementing anything** and treat them as the source of truth.  \
If any ambiguity appears, prefer consistency with:\
- The \'93no runtime UI layout generation\'94 rule.\
- The authoritative server model (server decides all real game state).\
- The modular, data-driven design (ScriptableObjects + editor tools).\
## Non-Negotiable Design Constraints\
\
- **Unity 6.2 client, 2D top-down, SNES style** visuals.\
- **Authoritative dedicated server** running on Ubuntu, with MariaDB as the DB.\
- Up to **6 players per dungeon session**.\
- A **main lobby / hub** where logged-in players hang out, chat, and form parties.\
- Procedurally generated dungeons using **room prefabs**, doors (locked/unlocked), keys, and triggers.\
- Rich RPG systems:\
  - Classes, abilities\
  - Limit break / trance system\
  - Status effects, buffs, debuffs\
  - DoT, HoT, resurrection, death\
  - Real-time action combat with cast times, attack speed, evasion\
  - Elemental system with weaknesses/resistances\
- **Editor-first mindset**:\
  - Use **Unity\'92s Canvas/UI system**.\
  - **Do NOT generate entire UIs at runtime.**\
  - Designers must be able to **see and edit UI layouts directly in the Unity editor**.\
  - Scripts are allowed to:\
    - Attach to pre-placed UI objects.\
    - Toggle visibility, populate lists using **existing prefabs**.\
    - Bind data and handle events.\
- Engine must be **modular, data-driven, and extendable**:\
  - ScriptableObjects and custom editor tools to define:\
    - Classes, abilities, status effects, enemy archetypes, loot tables, room templates, dungeon themes.\
  - Easy to add new room prefabs and room types.\
  - No semantic/code drift: systems should be clearly separated and well-named.\
\
## High-Level Architecture\
\
- **Unity Client**\
  - Handles input, rendering, camera, VFX, SFX, UI.\
  - Uses top-down 2D (like SNES Zelda) with nicer graphics.\
  - Talks to the server via a JSON-based protocol over TCP or WebSocket.\
  - Treats the server as **authoritative** for gameplay state.\
\
- **Server (C#, .NET 8)**\
  - Headless console app running on Ubuntu.\
  - Manages:\
    - Authentication, sessions\
    - Lobby/hub, chat, parties\
    - Dungeon instance creation and lifecycle\
    - Real-time simulation (movement, combat, status effects, dungeon state)\
    - Persistence to MariaDB\
\
- **MariaDB Backend**\
  - Persists accounts, characters, inventories, unlocks, dungeon runs, etc.\
  - Structured for future expansion and anti-cheat.\
  - Clients **never** talk to DB directly.\
\
## Important Docs\
\
Codex should read these files in this order:\
\
1. `docs/00_ADVENTUREBOT2_OVERVIEW.md`  \
2. `docs/01_CLIENT_UNITY_ARCHITECTURE.md`  \
3. `docs/02_SERVER_ARCHITECTURE_AND_NETWORKING.md`  \
4. `docs/03_DATABASE_SCHEMA.md`  \
5. `docs/04_GAME_SYSTEMS_AND_RULES.md`  \
6. `docs/05_DUNGEON_GENERATION_AND_EDITOR_TOOLS.md`  \
7. `docs/06_UNITY_SCENE_SETUP_AND_PREFABS.md`  \
8. `docs/07_TASKS_FOR_CODEX.md` \'96 this contains explicit implementation tasks.\
\
## Codex Instructions\
\
When generating code:\
\
- **Do not create UI hierarchies or Canvases via code**.  \
  - Only bind to, enable/disable, and populate elements that already exist in the scene as prefabs/layouts.\
- Keep **server logic separate** from networking and DB:\
  - Pure game logic layer.\
  - Network/message layer.\
  - Persistence/repository layer.\
- Prefer **plain C# structs/classes** for data models that represent:\
  - Characters, stats, abilities, status effects, dungeon rooms, etc.\
- Prefer **dependency injection** or simple composition for services (but keep it straightforward).\
- Add comments describing responsibilities and extension points.\
\
Implementation steps and concrete class lists are in `07_TASKS_FOR_CODEX.md`.\
}